---
layout: default
title: Redis 的應用
parent: RAG Methodologies
grand_parent: SearchingEngine
nav_order: 99
date: 2024-10-12 
last_modified_date: 2024-10-12 20:32:31
tags: AI chat report
---

# Redis 的應用
{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>
---

## 背景

- 雖然內存資料庫有快速的強項、RAG對語言的精度倒是不如金融資料庫，但如果能夠同時有個關聯資料庫作為跨session 的資料背景也是很重要。
- 這2類資料庫，前者方案以最簡單的Redis、而後者的方案則以最常見的MySQL作為長期管理。
- 整合搭配起來就如下圖所示。

![Redis and MySQL join service](https://hackmd.io/@cynote/BkobMykLw)
source: [hackmd](https://hackmd.io/@cynote/BkobMykLw)

## Redis 的鍵與值

{% include question.html content="作為RAG系統中的Redis緩存資料庫，其鍵與值會是什麼內容？" %}
- 在 Retrieval-Augmented Generation (RAG) 系統中，Redis 通常作為快取資料庫，用來加速向量檢索和減少對後端資料庫的查詢頻率。在這樣的場景下，Redis 的 鍵（key）和 值（value）會包含以下內容：

### 鍵（Key）

	•	查詢文本或查詢向量的哈希值：RAG 系統中的查詢可能是來自用戶輸入的文本，這些文本會經過向量化後生成一個向量。為了避免存儲過多的冗餘數據，通常會對這個查詢向量進行哈希運算，並將哈希值作為 Redis 的鍵。
	•	例子：query_hash:<query_text_hash> 或 query_vec_hash:<query_vector_hash>

### 值（Value）

	•	檢索結果的編號或 ID：當一個查詢對應於多個文檔檢索結果時，這些文檔的 ID 可以作為查詢的結果儲存在 Redis 中，避免再次向後端資料庫查詢。
	•	例子：一個查詢向量的值可以是相關文檔的 ID 列表，如 [doc_id_1, doc_id_2, doc_id_3]。
	•	相關文檔的向量：在某些情況下，RAG 系統會將向量化的文檔預先緩存，當查詢來臨時，直接從 Redis 中取回相關的文檔向量，而無需重新向量化或檢索。
	•	例子：doc_vec:<doc_id> 可以是文檔的嵌入向量。
	•	檢索結果的具體內容：為了加速生成的速度，RAG 系統也可以緩存檢索出的具體文檔片段或答案，從而省去在每次查詢時重新檢索和組合生成步驟。
	•	例子：response:<query_text_hash> 可能包含之前已生成的完整回答。

### Redis 使用的特性

	•	TTL（Time-to-Live）：Redis 支持設置鍵的過期時間，因此可以設定每個查詢結果的有效期，在這段時間內重複相同查詢可以直接從快取中獲取結果，而無需重新進行檢索和生成。
	•	LRU（Least Recently Used）策略：對於緩存較多內容時，Redis 的 LRU 策略可以幫助釋放空間，確保最常用的數據保持在快取中，提升系統性能。

### 具體應用場景

	1.	加速查詢檢索：如果查詢文本之前已被處理過，系統可以直接從 Redis 中調取結果，避免進行向量化和檢索，縮短響應時間。
	2.	減少向量計算：查詢向量和文檔向量的比對是計算密集型操作，將這些結果緩存在 Redis 中，可以避免頻繁的重複計算。
	3.	優化語義搜索結果：針對某些高頻查詢或重複查詢，預先緩存語義檢索結果，提升搜索系統的整體效能。

總結來說，Redis 在 RAG 系統中用作查詢結果快取，通過存儲查詢向量的哈希、檢索結果的 ID、文檔向量及其他必要資訊，減少了實時計算負荷，顯著提升了系統的查詢效率。

## 鍵的長度

{% include question.html content="Redis 鍵的長度、與內嵌的Token大小有什麼關係？" %}

Redis 鍵的長度與內嵌的 Token 數量之間沒有直接的技術關聯，但其設計仍會受到某些工程實踐和效能需求的影響。以下是相關的探討：

### 1. Redis 鍵的長度

Redis 鍵的長度理論上可以任意長，但實際應用中建議保持鍵的長度在合理範圍內，通常為幾十字元到一百字元。過長的鍵會：

	•	增加內存佔用：Redis 是基於內存運行的系統，長鍵會佔用更多的內存資源。
	•	降低查詢效率：雖然 Redis 是 O(1) 的查找操作，但過長的鍵在內存中會導致更多的比對開銷，特別是大量鍵的情況下。

### 2. 內嵌 Token 的大小

內嵌的 Token 數量主要影響的是文本向量化的結果，而不是直接與 Redis 鍵的長度相關。Token 是模型用來處理文本的最小單位，當你將一個文本向量化時，這些 Token 被模型轉換成一個固定維度的向量。向量的大小與模型的設計有關，而不是與 Redis 的鍵長度直接掛鉤。

### 3. 關鍵影響因素

	•	Hash 或 Key 設計：當我們將文本或其向量儲存在 Redis 中時，通常不會將整個文本作為鍵，而是會生成一個哈希值（如 SHA256）作為鍵。哈希值的長度固定，一般為 32 或 64 字元，這樣可以確保鍵的長度不會因文本長度而顯著增長。
	•	Token 與 Redis Value：向量化後的結果（即值）是多維數據，與 Token 數量有關。例如，更多 Token 會生成更長的向量，這可能導致存入 Redis 的值變得更大。這主要影響到 Redis 的儲存空間和網路傳輸時間，但與鍵的長度無關。

### 4. 實踐建議

	•	鍵長度控制：保持鍵簡潔，例如通過文本哈希或固定長度的唯一識別碼（UUID）作為鍵。
	•	Token 與向量化結果：確保使用有效的向量化方法和壓縮技術，避免生成過大的向量，減少 Redis 的存儲壓力。
	•	頻繁查詢的文本：可以考慮提前向量化並快取結果，以減少每次重新計算的開銷。

總結來說，Redis 鍵的長度與內嵌 Token 的大小之間並無直接聯繫，但在設計時應考慮內存效率、向量化過程中的結果大小，以及如何設計最佳的快取策略來提升查詢性能。

